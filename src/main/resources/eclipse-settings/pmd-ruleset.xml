<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ruleset xmlns="http://pmd.sf.net/ruleset/1.0.0" name="pmd-ruleset" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd" xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd">
   <description>sebhoss PMD rule set</description>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyCatchBlock" message="Avoid empty catch blocks" name="EmptyCatchBlock" since="0.1" typeResolution="true">
      <description>
Empty Catch Block finds instances where an exception is caught,
but nothing is done.  In most circumstances, this swallows an exception
which should either be acted on or reported.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//CatchStatement
 [count(Block/BlockStatement) = 0 and ($allowCommentedBlocks != 'true' or Block/@containsComment = 'false')]
 [FormalParameter/Type/ReferenceType
   /ClassOrInterfaceType[@Image != 'InterruptedException' and @Image != 'CloneNotSupportedException']
 ]
 
             ]]></value>
         </property>
         <property name="allowCommentedBlocks" value="false"/>
      </properties>
      <example><![CDATA[
  
public void doSomething() {
  try {
    FileInputStream fis = new FileInputStream("/tmp/bugger");
  } catch (IOException ioe) {
      // not good
  }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyIfStmt" message="Avoid empty 'if' statements" name="EmptyIfStmt" since="0.1" typeResolution="true">
      <description>
Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//IfStatement/Statement
 [EmptyStatement or Block[count(*) = 0]]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 void bar(int x) {
  if (x == 0) {
   // empty!
  }
 }
}
 
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyWhileStmt" message="Avoid empty 'while' statements" name="EmptyWhileStmt" since="0.2" typeResolution="true">
      <description>
Empty While Statement finds all instances where a while statement
does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//WhileStatement/Statement[./Block[count(*) = 0]  or ./EmptyStatement]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 void bar(int a, int b) {
  while (a == b) {
   // empty!
  }
 }
}
 
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyTryBlock" message="Avoid empty try blocks" name="EmptyTryBlock" since="0.4" typeResolution="true">
      <description>
Avoid empty try blocks - what's the point?
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//TryStatement/Block[1][count(*) = 0]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  try {
  } catch (Exception e) {
    e.printStackTrace();
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyFinallyBlock" message="Avoid empty finally blocks" name="EmptyFinallyBlock" since="0.4" typeResolution="true">
      <description>
Avoid empty finally blocks - these can be deleted.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//FinallyStatement[count(Block/BlockStatement) = 0]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  try {
    int x=2;
   } finally {
    // empty!
   }
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptySwitchStatements" message="Avoid empty switch statements" name="EmptySwitchStatements" since="1.0" typeResolution="true">
      <description>
Avoid empty switch statements.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SwitchStatement[count(*) = 1]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   // once there was code here
   // but it's been commented out or something
  }
 }
}
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#JumbledIncrementer" message="Avoid modifying an outer loop incrementer in an inner loop for update expression" name="JumbledIncrementer" since="1.0" typeResolution="true">
      <description>Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]]]></value>
         </property>
      </properties>
      <example><![CDATA[
 
public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
 
     ]]></example>
      <example><![CDATA[public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ForLoopShouldBeWhileLoop" message="This for loop could be simplified to a while loop" name="ForLoopShouldBeWhileLoop" since="1.02" typeResolution="true">
      <description>Some for loops can be simplified to while loops - this makes them more concise.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//ForStatement
 [count(*) > 1]
 [not(ForInit)]
 [not(ForUpdate)]
 [not(Type and Expression and Statement)]]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 void bar() {
  for (;true;) true; // No Init or Update part, may as well be: while (true)
 }
}
 
      ]]></example>
      <example><![CDATA[public class Foo {
 void bar() {
  for (;true;) true; // No Init or Update part, may as well be: while (true)
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporary" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryConversionTemporary" message="Avoid unnecessary temporaries when converting primitives to Strings" name="UnnecessaryConversionTemporary" since="0.1" typeResolution="true">
      <description>Avoid unnecessary temporaries when converting primitives to Strings</description>
      <priority>1</priority>
      <example><![CDATA[
  
public String convert(int x) {
  // this wastes an object
  String foo = new Integer(x).toString();
  // this is better
  return Integer.toString(x);
}
 
      ]]></example>
      <example><![CDATA[public String convert(int x) {
  // this wastes an object
  String foo = new Integer(x).toString();
  // this is better
  return Integer.toString(x);
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.OverrideBothEqualsAndHashcode" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#OverrideBothEqualsAndHashcode" message="Ensure you override both equals() and hashCode()" name="OverrideBothEqualsAndHashcode" since="0.4" typeResolution="true">
      <description>
Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
// this is bad
public class Bar {
  public boolean equals(Object o) {
      // do some comparison
  }
}

// and so is this
public class Baz {
  public int hashCode() {
      // return some hash value
  }
}

// this is OK
public class Foo {
  public boolean equals(Object other) {
      // do some comparison
  }
  public int hashCode() {
      // return some hash value
  }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.DoubleCheckedLocking" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#DoubleCheckedLocking" message="Double checked locking is not thread safe in Java." name="DoubleCheckedLocking" since="1.04" typeResolution="true">
      <description>
Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
An optimizing JRE may assign a reference to the baz variable before it creates the object the
  reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
public class Foo {
  Object baz;
  Object bar() {
    if(baz == null) { //baz may be non-null yet not fully created
      synchronized(this){
        if(baz == null){
          baz = new Object();
        }
      }
    }
    return baz;
  }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ReturnFromFinallyBlock" message="Avoid returning from a finally block" name="ReturnFromFinallyBlock" since="1.05" typeResolution="true">
      <description>
Avoid returning from a finally block - this can discard exceptions.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//FinallyStatement//ReturnStatement

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 public String foo() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptySynchronizedBlock" message="Avoid empty synchronized blocks" name="EmptySynchronizedBlock" since="1.3" typeResolution="true">
      <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SynchronizedStatement/Block[1][count(*) = 0]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar() {
  synchronized (this) {
   // empty!
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.UnnecessaryReturn" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryReturn" message="Avoid unnecessary return statements" name="UnnecessaryReturn" since="1.3" typeResolution="true">
      <description>
Avoid unnecessary return statements
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  int x = 42;
  return;
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyStaticInitializer" message="Empty static initializer was found" name="EmptyStaticInitializer" since="1.5" typeResolution="true">
      <description>
An empty static initializer was found.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//Initializer[@Static='true']/Block[count(*)=0]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 static {
  // empty
 }
 }

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnconditionalIfStatement" message="Do not use 'if' statements that are always true or always false" name="UnconditionalIfStatement" since="1.5" typeResolution="true">
      <description>
Do not use "if" statements that are always true or always false.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyStatementNotInLoop" message="An empty statement (semicolon) not part of a loop" name="EmptyStatementNotInLoop" since="1.5" typeResolution="true">
      <description>
An empty statement (aka a semicolon by itself) that is not used
as the sole body of a for loop or while loop is probably a bug.  It
could also be a double semicolon, which is useless and should be
removed.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//EmptyStatement
 [not(
       ../../../ForStatement
       or ../../../WhileStatement
       or ../../../BlockStatement/ClassOrInterfaceDeclaration
       or ../../../../../../ForStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement
       or ../../../../../../WhileStatement/Statement[1]
        /Block[1]/BlockStatement[1]/Statement/EmptyStatement)
 ]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class MyClass {
   public void doit() {
      // this is probably not what you meant to do
      ;
      // the extra semicolon here this is not necessary
      System.out.println("look at the extra semicolon");;
   }
}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BooleanInstantiation" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BooleanInstantiation" message="Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead." name="BooleanInstantiation" since="1.2" typeResolution="true">
      <description>
Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf() instead.
   </description>
      <priority>1</priority>
      <example><![CDATA[
   
public class Foo {
 Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE;
 Boolean buz = Boolean.valueOf(false); // just do a Boolean buz = Boolean.FALSE;
}
   
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryFinalModifier" message="Unnecessary final modifier in final class" name="UnnecessaryFinalModifier" since="3.0" typeResolution="true">
      <description>
When a class has the final modifier, all the methods are automatically final.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//ClassOrInterfaceDeclaration[@Final='true' and @Interface='false']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/MethodDeclaration[@Final='true']
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public final class Foo {
    // This final modifier is not necessary, since the class is final
    // and thus, all methods are final
    private final void foo() {
    }
}


      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#CollapsibleIfStatements" message="These nested if statements could be combined" name="CollapsibleIfStatements" since="3.1" typeResolution="true">
      <description>Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//IfStatement[@Else='false']/Statement
 /IfStatement[@Else='false']
 |
//IfStatement[@Else='false']/Statement
 /Block[count(BlockStatement)=1]/BlockStatement
  /Statement/IfStatement[@Else='false']]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 void bar() {
  if (x) {
   if (y) {
    // do stuff
   }
  }
 }
}
 
      ]]></example>
      <example><![CDATA[public class Foo {
 void bar() {
  if (x) {
   if (y) {
    // do stuff
   }
  }
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UselessOverridingMethod" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UselessOverridingMethod" message="Overriding method merely calls super" name="UselessOverridingMethod" since="3.3" typeResolution="true">
      <description>The overriding method merely calls the same method defined in a superclass</description>
      <priority>1</priority>
      <properties>
         <property name="ignoreAnnotations" value="false"/>
      </properties>
      <example><![CDATA[
public void foo(String bar) {
    super.foo(bar);      //Why bother overriding?
}
        ]]></example>
      <example><![CDATA[
public String foo() {
    return super.foo();  //Why bother overriding?
}
        ]]></example>
      <example><![CDATA[
@Id
public Long getId() {
    return super.getId();  //OK if 'ignoreAnnotations' is false, which is the default behavior
}
        ]]></example>
      <example><![CDATA[public void foo(String bar) {
    super.foo(bar);      //Why bother overriding?
}

public String foo() {
    return super.foo();  //Why bother overriding?
}

@Id
public Long getId() {
    return super.getId();  //OK if 'ignoreAnnotations' is false, which is the default behavior
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#ClassCastExceptionWithToArray" message="This usage of the Collection.toArray() method will throw a ClassCastException." name="ClassCastExceptionWithToArray" since="3.4" typeResolution="true">
      <description>
if you need to get an array of a class from your Collection,
you should pass an array of the desidered class
as the parameter of the toArray method. Otherwise you will get a
ClassCastException.
  </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//CastExpression[Type/ReferenceType/ClassOrInterfaceType[@Image !=
"Object"]]//PrimaryExpression
[
 PrimaryPrefix/Name[ends-with(@Image, '.toArray')]
 and
 PrimarySuffix/Arguments[count(*) = 0]
and
count(PrimarySuffix) = 1
]

    ]]></value>
         </property>
      </properties>
      <example><![CDATA[

import java.util.ArrayList;
import java.util.Collection;

public class Test {

    public static void main(String[] args) {
        Collection c=new ArrayList();
        Integer obj=new Integer(1);
        c.add(obj);

        // this would trigger the rule (and throw a ClassCastException
if executed)
        Integer[] a=(Integer [])c.toArray();

        // this wouldn't trigger the rule
        Integer[] b=(Integer [])c.toArray(new Integer[c.size()]);
    }
}

  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidDecimalLiteralsInBigDecimalConstructor" message="Avoid creating BigDecimal with a decimal (float/double) literal. Use a String literal" name="AvoidDecimalLiteralsInBigDecimalConstructor" since="3.4" typeResolution="true">
      <description>
     One might assume that "new BigDecimal(.1)" is exactly equal
     to .1, but it is actually equal
     to .1000000000000000055511151231257827021181583404541015625.
     This is so because .1 cannot be represented exactly as a double
     (or, for that matter, as a binary fraction of any finite length).
     Thus, the long value that is being passed in to the constructor
     is not exactly equal to .1, appearances notwithstanding.

     The (String) constructor, on the other hand, is perfectly predictable:
     'new BigDecimal(".1")' is exactly equal to .1, as one
     would expect.  Therefore, it is generally recommended that the (String)
     constructor be used in preference to this one.
  </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//AllocationExpression[ClassOrInterfaceType[@Image="BigDecimal"]
and
./Arguments/ArgumentList
/Expression/PrimaryExpression/PrimaryPrefix/Literal[(not
(ends-with
(@Image,'"'))) and contains(@Image,".")]]
 
    ]]></value>
         </property>
      </properties>
      <example><![CDATA[

import java.math.BigDecimal;
public class Test {

    public static void main(String[] args) {
      // this would trigger the rule
     BigDecimal bd=new BigDecimal(1.123);
      // this wouldn't trigger the rule
     BigDecimal bd=new BigDecimal("1.123");
      // this wouldn't trigger the rule
     BigDecimal bd=new BigDecimal(12);
    }
}

  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UselessOperationOnImmutable" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UselessOperationOnImmutable" message="An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself" name="UselessOperationOnImmutable" since="3.5" typeResolution="true">
      <description>
    An operation on an Immutable object (String, BigDecimal or BigInteger) won't change the object itself. The
    result of the operation is a new object. Therefore, ignoring the operation result is an error.
      </description>
      <priority>1</priority>
      <example><![CDATA[
    
import java.math.*;
class Test {
 void method1() {
  BigDecimal bd=new BigDecimal(10);
  bd.add(new BigDecimal(5)); // this will trigger the rule
 }
 void method2() {
  BigDecimal bd=new BigDecimal(10);
  bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
 }
}
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#MisplacedNullCheck" message="The null check here is misplaced; if the variable is null there'll be a NullPointerException" name="MisplacedNullCheck" since="3.5" typeResolution="true">
      <description>
    The null check here is misplaced. if the variable is null you'll get a NullPointerException.
    Either the check is useless (the variable will never be "null") or it's incorrect.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//Expression
    /*[self::ConditionalOrExpression or self::ConditionalAndExpression]
     /descendant::PrimaryExpression/PrimaryPrefix
      /Name[starts-with(@Image,
      concat(ancestor::PrimaryExpression/following-sibling::EqualityExpression
       [./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
     /PrimaryExpression/PrimaryPrefix
      /Name[count(../../PrimarySuffix)=0]/@Image,"."))
    ]
    
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 void bar() {
  if (a.equals(baz) && a != null) {}
 }
}
    
      ]]></example>
      <example><![CDATA[
public class Foo {
 void bar() {
  if (a.equals(baz) || a == null) {}
 }
}
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnusedNullCheckInEquals" message="Invoke equals() on the object you''ve already ensured is not null" name="UnusedNullCheckInEquals" since="3.5" typeResolution="true">
      <description>
    After checking an object reference for null, you should invoke equals() on that object rather than passing it to another object's equals() method.
    </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
        
//PrimarySuffix[@Image='equals' and not(../PrimaryPrefix/Literal)]
 /following-sibling::PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression[count(PrimarySuffix)=0]/PrimaryPrefix
 /Name[@Image = ./../../../../../../../../../../Expression/ConditionalAndExpression
 /EqualityExpression[@Image="!=" and count(./preceding-sibling::*)=0 and
 ./PrimaryExpression/PrimaryPrefix/Literal/NullLiteral]
  /PrimaryExpression/PrimaryPrefix/Name/@Image]
        
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Test {

public String method1() { return "ok";}
public String method2() { return null;}

public void method(String a) {
String b;
/*
I don't know it method1() can be "null"
but I know "a" is not null..
I'd better write a.equals(method1())
*/
if (a!=null && method1().equals(a)) { // will
trigger the rule
//whatever
}

if (method1().equals(a) && a != null) { //
won't trigger the rule
//whatever
}

if (a!=null && method1().equals(b)) { // won't
trigger the rule
//whatever
}

if (a!=null && "LITERAL".equals(a)) { // won't
trigger the rule
//whatever
}

if (a!=null && !a.equals("go")) { // won't
trigger the rule
a=method2();
if (method1().equals(a)) {
//whatever
}
}
}
}

]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidThreadGroup" message="Avoid using ThreadGroup; it is not thread safe" name="AvoidThreadGroup" since="3.6" typeResolution="true">
      <description>Avoid using ThreadGroup; although it is intended to be used in a threaded environment
 it contains methods that are not thread safe.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//AllocationExpression/ClassOrInterfaceType[contains(@Image,'ThreadGroup')] |
//PrimarySuffix[contains(@Image, 'getThreadGroup')]]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
    public class Bar {
     void buz() {
      ThreadGroup tg = new ThreadGroup("My threadgroup") ;
      tg = new ThreadGroup(tg, "my thread group");
      tg = Thread.currentThread().getThreadGroup();
      tg = System.getSecurityManager().getThreadGroup();
     }
    }
    
      ]]></example>
      <example><![CDATA[public class Bar {
     void buz() {
      ThreadGroup tg = new ThreadGroup("My threadgroup") ;
      tg = new ThreadGroup(tg, "my thread group");
      tg = Thread.currentThread().getThreadGroup();
      tg = System.getSecurityManager().getThreadGroup();
     }
    }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BrokenNullCheck" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BrokenNullCheck" message="Method call on object which may be null" name="BrokenNullCheck" since="3.8" typeResolution="true">
      <description>
The null check is broken since it will throw a NullPointerException itself.
It is likely that you used || instead of &amp;&amp; or vice versa.
     </description>
      <priority>1</priority>
      <example><![CDATA[

class Foo {
 String bar(String string) {
  // should be &&
  if (string!=null || !string.equals(""))
    return string;
  // should be ||
  if (string==null && string.equals(""))
    return string;
 }
}
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.BigIntegerInstantiation" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#BigIntegerInstantiation" message="Don't create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN)" name="BigIntegerInstantiation" since="3.9" typeResolution="true">
      <description>
Don't create instances of already existing BigInteger
(BigInteger.ZERO, BigInteger.ONE) and for 1.5 on,
BigInteger.TEN and BigDecimal (BigDecimal.ZERO,
BigDecimal.ONE, BigDecimal.TEN)
  </description>
      <priority>1</priority>
      <example><![CDATA[

public class Test {

 public static void main(String[] args) {
   BigInteger bi=new BigInteger(1);
   BigInteger bi2=new BigInteger("0");
   BigInteger bi3=new BigInteger(0.0);
   BigInteger bi4;
   bi4=new BigInteger(0);
 }
}

  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.AvoidUsingOctalValues" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidUsingOctalValues" message="Do not start a literal by 0 unless it's an octal value" name="AvoidUsingOctalValues" since="3.9" typeResolution="true">
      <description>Integer literals should not start with zero.
		    Zero means that the rest of literal will be interpreted as an octal value.</description>
      <priority>1</priority>
      <example><![CDATA[
		    
		public class Foo {
		  int i = 012; // set i with 10 not 12
		  int j = 010; // set j with 8 not 10
		  k = i * j; // set k with 80 not 120
		}
		    
    ]]></example>
      <example><![CDATA[public class Foo {
		  int i = 012; // set i with 10 not 12
		  int j = 010; // set j with 8 not 10
		  k = i * j; // set k with 80 not 120
		}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.AvoidUsingHardCodedIP" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidUsingHardCodedIP" message="Do not hard code IPv4 or IPv6 addresses, even 127.0.0.1 !" name="AvoidUsingHardCodedIP" since="4.1" typeResolution="true">
      <description>An application with hard coded IP may become impossible to deploy in some case. It never hurts
				to externalize IP adresses.</description>
      <priority>1</priority>
      <properties>
         <property name="pattern" value="^&quot;[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}&quot;$"/>
      </properties>
      <example><![CDATA[
	    
	public class Foo {
	  String ip = "127.0.0.1"; // This is a really bad idea !
	}
	    
	    ]]></example>
      <example><![CDATA[public class Foo {
	  String ip = "127.0.0.1"; // This is a really bad idea !
	}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#CheckResultSet" message="Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet." name="CheckResultSet" since="4.1" typeResolution="true">
      <description>Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet. Indeed,
	            if the value return is 'false', the developer should deal with it !</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//Type/ReferenceType/ClassOrInterfaceType[
        (@Image = 'ResultSet')
        and
        (../../../descendant::Name[ends-with(@Image,'executeQuery')])
        and
        (
	(not (contains(
                        (./ancestor::Block/descendant::WhileStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.next')
		)  ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.next')
		) ) )
	and (not (contains(
                        (./ancestor::Block/descendant::WhileStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.previous')
		)  ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.previous')
		) ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.last')
		) ) )
	and ( not ( contains(
                        (./ancestor::Block/descendant::IfStatement/descendant::Name/attribute::Image),
                        concat(../../../VariableDeclarator/VariableDeclaratorId/attribute::Image,'.first')
		) ) )

         )
]]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
            // This is NOT appropriate !
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            rst.next(); // what if it returns a 'false' ?
            String firstName = rst.getString(1);

            // This is appropriate...
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            if (rst.next())
            {
                String firstName = rst.getString(1);
            }
            else
            {
                // here you deal with the error ( at least log it)
            }
            
        ]]></example>
      <example><![CDATA[// This is NOT appropriate !
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            rst.next(); // what if it returns a 'false' ?
            String firstName = rst.getString(1);

            // This is appropriate...
            Statement stat = conn.createStatement();
            ResultSet rst = stat.executeQuery("SELECT name FROM person");
            if (rst.next())
            {
                String firstName = rst.getString(1);
            }
            else
            {
                // here you deal with the error ( at least log it)
            }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.basic.AvoidMultipleUnaryOperators" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#AvoidMultipleUnaryOperators" message="Using multiple unary operators may be a bug, and/or is confusing." name="AvoidMultipleUnaryOperators" since="4.2" typeResolution="true">
      <description>Using multiple unary operators may be a bug, and/or is confusing.
					Check the usage is not a bug, or consider simplifying the expression.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//UnaryExpression[
		./UnaryExpression
		or ./UnaryExpressionNotPlusMinus
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpression
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpressionNotPlusMinus
	]
|
//UnaryExpressionNotPlusMinus[
		./UnaryExpression
		or ./UnaryExpressionNotPlusMinus
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpression
		or ./PrimaryExpression/PrimaryPrefix/Expression/UnaryExpressionNotPlusMinus
	]]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
            // These are typo bugs, or at best needlessly complex and confusing:
            int i = - -1;
            int j = + - +1;
            int z = ~~2;
            boolean b = !!true;
            boolean c = !!!true;

            // These are better:
            int i = 1;
            int j = -1;
            int z = 2;
            boolean b = true;
            boolean c = false;

            // And these just make your brain hurt:
            int i = ~-2;
            int j = -~7;
            
        ]]></example>
      <example><![CDATA[// These are typo bugs, or at best needlessly complex and confusing:
            int i = - -1;
            int j = + - +1;
            int z = ~~2;
            boolean b = !!true;
            boolean c = !!!true;

            // These are better:
            int i = 1;
            int j = -1;
            int z = 2;
            boolean b = true;
            boolean c = false;

            // And these just make your brain hurt:
            int i = ~-2;
            int j = -~7;]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#EmptyInitializer" message="Empty initializer was found" name="EmptyInitializer" since="5.0" typeResolution="true">
      <description>
An empty initializer was found.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//Initializer/Block[count(*)=0]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {

   static {} // Why ?

   {} // Again, why ?

}
    
    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UseSingleton" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseSingleton" message="All methods are static.  Consider using Singleton instead.  Alternatively, you could add a private constructor or make the class abstract to silence this warning." name="UseSingleton" since="0.3" typeResolution="true">
      <description>
    	
If you have a class that has nothing but static methods, consider making it a Singleton.
Note that this doesn't apply to abstract classes, since their subclasses may
well include non-static methods.  Also, if you want this class to be a Singleton,
remember to add a private constructor to prevent instantiation.
		
    </description>
      <priority>1</priority>
      <example><![CDATA[

public class MaybeASingleton {
 public static void foo() {}
 public static void bar() {}
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.SimplifyBooleanReturns" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyBooleanReturns" message="Avoid unnecessary if..then..else statements when returning a boolean" name="SimplifyBooleanReturns" since="0.9" typeResolution="true">
      <description>
Avoid unnecessary if..then..else statements when returning a boolean.
    </description>
      <priority>1</priority>
      <example><![CDATA[

public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyBooleanExpressions" message="Avoid unnecessary comparisons in boolean expressions" name="SimplifyBooleanExpressions" since="1.05" typeResolution="true">
      <description>
Avoid unnecessary comparisons in boolean expressions - this complicates simple code.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//EqualityExpression/PrimaryExpression
 /PrimaryPrefix/Literal/BooleanLiteral

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SwitchStmtsShouldHaveDefault" message="Switch statements should have a default label" name="SwitchStmtsShouldHaveDefault" since="1.0" typeResolution="true">
      <description>
Switch statements should have a default label.
    </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//SwitchStatement[not(SwitchLabel[@Default='true'])]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidDeeplyNestedIfStmts" message="Deeply nested if..then statements are hard to read" name="AvoidDeeplyNestedIfStmts" since="1.0" typeResolution="true">
      <description>Deeply nested if..then statements are hard to read.</description>
      <priority>1</priority>
      <properties>
         <property name="problemDepth" value="3"/>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar(int x, int y, int z) {
  if (x>y) {
   if (y>z) {
    if (z==x) {
     // whew, too deep
    }
   }
  }
 }
}

    ]]></example>
      <example><![CDATA[public class Foo {
 public void bar(int x, int y, int z) {
  if (x>y) {
   if (y>z) {
    if (z==x) {
     // whew, too deep
    }
   }
  }
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidReassigningParameters" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidReassigningParameters" message="Avoid reassigning parameters such as ''{0}''" name="AvoidReassigningParameters" since="1.0" typeResolution="true">
      <description>
Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.
    </description>
      <priority>1</priority>
      <example><![CDATA[

public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.SwitchDensityRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SwitchDensity" message="A high ratio of statements to labels in a switch statement.  Consider refactoring." name="SwitchDensity" since="1.02" typeResolution="true">
      <description>
 A high ratio of statements to labels in a switch statement implies that the switch
 statement is doing too much work.  Consider moving the statements into new
 methods, or creating subclasses based on the switch variable.
      </description>
      <priority>1</priority>
      <properties>
         <property name="minimum" value="10"/>
      </properties>
      <example><![CDATA[
 
public class Foo {
 public void bar(int x) {
   switch (x) {
     case 1: {
       // lots of statements
       break;
     } case 2: {
       // lots of statements
       break;
     }
   }
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ConstructorCallsOverridableMethod" message="Overridable {0} called during object construction" name="ConstructorCallsOverridableMethod" since="1.04" typeResolution="true">
      <description>
Calling overridable methods during construction poses a risk of invoking methods on an
incompletely constructed object and can be difficult to discern.
It may leave the sub-class unable to construct its superclass or forced to
replicate the construction process completely within itself, losing the ability to call
super().  If the default constructor contains a call to an overridable method,
the subclass may be completely uninstantiable.   Note that this includes method calls
throughout the control flow graph - i.e., if a constructor Foo() calls a private method
bar() that calls a public method buz(), this denotes a problem.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
public class SeniorClass {
  public SeniorClass(){
      toString(); //may throw NullPointerException if overridden
  }
  public String toString(){
    return "IAmSeniorClass";
  }
}
public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass(){
    super(); //Automatic call leads to NullPointerException
    name = "JuniorClass";
  }
  public String toString(){
    return name.toUpperCase();
  }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AccessorClassGeneration" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AccessorClassGeneration" message="Avoid instantiation through private constructors from outside of the constructor's class." name="AccessorClassGeneration" since="1.04" typeResolution="true">
      <description>Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
A factory method, or non-privitization of the constructor can eliminate this situation.
The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
one with package scope, and is challenging to discern.</description>
      <priority>1</priority>
      <example><![CDATA[
  
public class Outer {
 void method(){
  Inner ic = new Inner();//Causes generation of accessor class
 }
 public class Inner {
  private Inner(){}
 }
}
  
      ]]></example>
      <example><![CDATA[public class Outer {
 void method(){
  Inner ic = new Inner();//Causes generation of accessor class
 }
 public class Inner {
  private Inner(){}
 }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#FinalFieldCouldBeStatic" message="This final field could be made static" name="FinalFieldCouldBeStatic" since="1.1" typeResolution="true">
      <description>
If a final field is assigned to a compile-time constant, it could be
made static, thus saving overhead in each object at runtime.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.CloseResource" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#CloseResource" message="Ensure that resources like this {0} object are closed after use" name="CloseResource" since="1.2.2" typeResolution="true">
      <description>
Ensure that resources (like Connection, Statement, and ResultSet objects) are always closed after use.
    </description>
      <priority>1</priority>
      <properties>
         <property name="types" value="Connection,Statement,ResultSet"/>
      </properties>
      <example><![CDATA[

public class Bar {
 public void foo() {
  Connection c = pool.getConnection();
  try {
    // do stuff
  } catch (SQLException ex) {
    // handle exception
  } finally {
    // oops, should close the connection using 'close'!
    // c.close();
  }
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonStaticInitializer" message="Non-static initializers are confusing" name="NonStaticInitializer" since="1.5" typeResolution="true">
      <description>
A nonstatic initializer block will be called any time a constructor
is invoked (just prior to invoking the constructor).  While this
is a valid language construct, it is rarely used and is confusing.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//Initializer[@Static='false']

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#DefaultLabelNotLastInSwitchStmt" message="The default label should be the last label in a switch statement" name="DefaultLabelNotLastInSwitchStmt" since="1.5" typeResolution="true">
      <description>
By convention, the default label should be the last label in a switch statement.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SwitchStatement
 [not(SwitchLabel[position() = last()][@Default='true'])]
 [SwitchLabel[@Default='true']]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:  // do something
      break;
   default:  // the default case should be last, by convention
      break;
   case 2:
      break;
  }
 }
}   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonCaseLabelInSwitchStatement" message="A non-case label was present in a switch statement" name="NonCaseLabelInSwitchStatement" since="1.5" typeResolution="true">
      <description>
A non-case label (e.g. a named break/continue label) was present in a switch statement.
This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//SwitchStatement//BlockStatement/Statement/LabeledStatement
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#OptimizableToArrayCall" message="This call to Collection.toArray() may be optimizable" name="OptimizableToArrayCall" since="1.8" typeResolution="true">
      <description>
A call to Collection.toArray can use the Collection's size vs an empty Array of the desired type.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//PrimaryExpression
[PrimaryPrefix/Name[ends-with(@Image, 'toArray')]]
[
PrimarySuffix/Arguments/ArgumentList/Expression
 /PrimaryExpression/PrimaryPrefix/AllocationExpression
 /ArrayDimsAndInits/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image='0']
]

                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
class Foo {
 void bar(Collection x) {
   // A bit inefficient
   x.toArray(new Foo[0]);
   // Much better; this one sizes the destination array, avoiding
   // a reflection call in some Collection implementations
   x.toArray(new Foo[x.size()]);
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#BadComparison" message="Avoid equality comparisons with Double.NaN" name="BadComparison" since="1.8" typeResolution="true">
      <description>
Avoid equality comparisons with Double.NaN - these are likely to be logic errors.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 boolean x = (y == Double.NaN);
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EqualsNull" message="Avoid using equals() to compare against null" name="EqualsNull" since="1.9" typeResolution="true">
      <description>
Inexperienced programmers sometimes confuse comparison concepts
and use equals() to compare to null.
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//PrimaryExpression
 [
PrimaryPrefix/Name[ends-with(@Image, 'equals')]
or
PrimarySuffix[ends-with(@Image, 'equals')]
]
[PrimarySuffix/Arguments/ArgumentList[count(Expression)=1]
  /Expression/PrimaryExpression/PrimaryPrefix
   /Literal/NullLiteral]
    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
       
class Bar {
   void foo() {
       String x = "foo";
       if (x.equals(null)) { // bad!
        doSomething();
       }
   }
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.ConfusingTernary" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ConfusingTernary" message="Avoid if (x != y) ..; else ..;" name="ConfusingTernary" since="1.9" typeResolution="true">
      <description>
In an "if" expression with an "else" clause, avoid negation in
the test.  For example, rephrase:
if (x != y) diff(); else same();
as:
if (x == y) same(); else diff();
Most "if (x != y)" cases without an "else" are often return
cases, so consistent use of this rule makes the code easier
to read.  Also, this resolves trivial ordering problems, such
as "does the error case go first?" or "does the common case
go first?".
        </description>
      <priority>1</priority>
      <example><![CDATA[
          
public class Foo {
 boolean bar(int x, int y) {
  return (x != y) ? diff : same;
 }
}          
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#InstantiationToGetClass" message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead" name="InstantiationToGetClass" since="2.0" typeResolution="true">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 // Replace this
 Class c = new String().getClass();
 // with this:
 Class c = String.class;
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.IdempotentOperations" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#IdempotentOperations" message="Avoid idempotent operations (like assigning a variable to itself)." name="IdempotentOperations" since="2.0" typeResolution="true">
      <description>
Avoid idempotent operations - they are have no effect.
      </description>
      <priority>1</priority>
      <example><![CDATA[
      
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
      
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimpleDateFormatNeedsLocale" message="When instantiating a SimpleDateFormat object, specify a Locale" name="SimpleDateFormatNeedsLocale" since="2.0" typeResolution="true">
      <description>
Be sure to specify a Locale when creating a new instance of SimpleDateFormat.
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//AllocationExpression
 [ClassOrInterfaceType[@Image='SimpleDateFormat']]
 [Arguments[@ArgumentCount=1]]

                    ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        
public class Foo {
 // Should specify Locale.US (or whatever)
 private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
}
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.ImmutableField" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ImmutableField" message="Private field ''{0}'' could be made final; it is only initialized in the declaration or constructor." name="ImmutableField" since="2.0" typeResolution="true">
      <description>
Identifies private fields whose values never change once they are initialized either in the declaration of the field or by
a constructor.  This aids in converting existing classes to immutable classes.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
public class Foo {
  private int x; // could be final
  public Foo() {
      x = 7;
  }
  public void foo() {
     int a = x + 2;
  }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseLocaleWithCaseConversions" message="When doing a String.toLowerCase()/toUpperCase() call, use a Locale" name="UseLocaleWithCaseConversions" since="2.0" typeResolution="true">
      <description>
When doing a String.toLowerCase()/toUpperCase() call, use a Locale.  This avoids
problems with certain locales, i.e. Turkish.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//PrimaryExpression
[PrimaryPrefix/Name
 [ends-with(@Image, 'toLowerCase') or ends-with(@Image,
'toUpperCase')]
 ]
[PrimarySuffix[position() = 1]/Arguments[@ArgumentCount=0]]
     
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
class Foo {
 // BAD
 if (x.toLowerCase().equals("list"))...
 /*
 This will not match "LIST" when in Turkish locale
 The above could be
 if (x.toLowerCase(Locale.US).equals("list")) ...
 or simply
 if (x.equalsIgnoreCase("list")) ...
 */
 // GOOD
 String z = a.toLowerCase(Locale.EN);
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidProtectedFieldInFinalClass" message="Avoid protected fields in a final class.  Change to private or package access." name="AvoidProtectedFieldInFinalClass" since="2.1" typeResolution="true">
      <description>Do not use protected fields in final classes since they cannot be subclassed.
Clarify your intent by using private or package access modifiers instead.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//ClassOrInterfaceDeclaration[@Final='true']
/ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration
/FieldDeclaration[@Protected='true']]]></value>
         </property>
      </properties>
      <example><![CDATA[

public final class Bar {
 private int x;
 protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
 Bar() {}
}
 
         ]]></example>
      <example><![CDATA[public final class Bar {
 private int x;
 protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
 Bar() {}
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.AssignmentToNonFinalStatic" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AssignmentToNonFinalStatic" message="Possible unsafe assignment to a non-final static field in a constructor." name="AssignmentToNonFinalStatic" since="2.2" typeResolution="true">
      <description>Identifies a possible unsafe usage of a static field.</description>
      <priority>1</priority>
      <example><![CDATA[
   
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
   
       ]]></example>
      <example><![CDATA[public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#MissingStaticMethodInNonInstantiatableClass" message="Class cannot be instantiated and does not provide any static methods or fields" name="MissingStaticMethodInNonInstantiatableClass" since="3.0" typeResolution="true">
      <description>
A class that has private constructors and does not have any static methods or fields cannot be used.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//ClassOrInterfaceDeclaration[@Nested='false'][
( count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration)>0
  and count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration) = count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private='true']) )
and
count(.//MethodDeclaration[@Static='true'])=0
and
count(.//FieldDeclaration[@Private='false'][@Static='true'])=0
]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

/* This class is unusable, since it cannot be
 instantiated (private constructor),
 and no static method can be called.
 */
public class Foo {
 private Foo() {}
 void foo() {}
}


      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidSynchronizedAtMethodLevel" message="Use block level rather than method level synchronization" name="AvoidSynchronizedAtMethodLevel" since="3.0" typeResolution="true">
      <description>
  Method level synchronization can backfire when new code is added to the method.  Block-level
  synchronization helps to ensure that only the code that needs synchronization gets it.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//MethodDeclaration[@Synchronized='true']
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 // Try to avoid this
 synchronized void foo() {
 }
 // Prefer this:
 void bar() {
  synchronized(this) {
  }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#MissingBreakInSwitch" message="A switch statement does not contain a break" name="MissingBreakInSwitch" since="3.0" typeResolution="true">
      <description>
A switch statement without an enclosed break statement may be a bug.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//SwitchStatement
[count(.//BreakStatement)=0]
[count(SwitchLabel) > 0]
[count(BlockStatement/Statement/ReturnStatement)
 + count(BlockStatement/Statement/ThrowStatement)
     < count (SwitchLabel)]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar(int status) {
  switch(status) {
   case CANCELLED:
    doCancelled();
    // break; hm, should this be commented out?
   case NEW:
    doNew();
   case REMOVED:
    doRemoved();
   }
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseNotifyAllInsteadOfNotify" message="Call Thread.notifyAll() rather than Thread.notify()" name="UseNotifyAllInsteadOfNotify" since="3.0" typeResolution="true">
      <description>
Thread.notify() awakens a thread monitoring the object. If more than one thread is monitoring, then only
one is chosen.  The thread chosen is arbitrary; thus it's usually safer to call notifyAll() instead.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//StatementExpression/PrimaryExpression
[count(PrimarySuffix/Arguments/ArgumentList) = 0]
[
PrimaryPrefix[./Name[@Image='notify' or ends-with(@Image,'.notify')]
or @Image='notify'
or (./AllocationExpression and ../PrimarySuffix[@Image='notify'])
]
]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 void bar() {
  x.notify();
  // If many threads are monitoring x, only one (and you won't know which) will be notified.
  // use instead:
  x.notifyAll();
 }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AbstractClassWithoutAbstractMethod" message="This abstract class does not have any abstract methods" name="AbstractClassWithoutAbstractMethod" since="3.0" typeResolution="true">
      <description>The abstract class does not contain any abstract methods. An abstract class suggests
an incomplete implementation, which is to be completed by subclasses implementing the
abstract methods. If the class is intended to be used as a base class only (not to be instantiated
direcly) a protected constructor can be provided prevent direct instantiation.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
  [count(.//ExtendsList)=0]]]></value>
         </property>
      </properties>
      <example><![CDATA[

public abstract class Foo {
 void int method1() { ... }
 void int method2() { ... }
 // consider using abstract methods or removing
 // the abstract modifier and adding protected constructors
}

      ]]></example>
      <example><![CDATA[public abstract class Foo {
 void int method1() { ... }
 void int method2() { ... }
 // consider using abstract methods or removing
 // the abstract modifier and adding protected constructors
}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyConditional" message="No need to check for null before an instanceof" name="SimplifyConditional" since="3.1" typeResolution="true">
      <description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
          </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                      
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      /PrimaryExpression/PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression/PrimaryExpression/PrimaryPrefix/Name/@Image]]]
 
                  ]]></value>
         </property>
      </properties>
      <example><![CDATA[
      
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      
           ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.CompareObjectsWithEquals" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#CompareObjectsWithEquals" message="Use equals() to compare object references." name="CompareObjectsWithEquals" since="3.2" typeResolution="true">
      <description>
 Use equals() to compare object references; avoid comparing them with ==.
  </description>
      <priority>1</priority>
      <example><![CDATA[

class Foo {
 boolean bar(String a, String b) {
  return a == b;
 }
}


  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#PositionLiteralsFirstInComparisons" message="Position literals first in String comparisons" name="PositionLiteralsFirstInComparisons" since="3.3" typeResolution="true">
      <description>
 Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false.
  </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
              
//PrimaryExpression[
        PrimaryPrefix[Name
                [
	(ends-with(@Image, '.equals'))
                ]
        ]
        [
                   (../PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Literal)
	and
	( count(../PrimarySuffix/Arguments/ArgumentList/Expression) = 1 )
        ]
]
[not(ancestor::Expression/ConditionalAndExpression//EqualityExpression[@Image='!=']//NullLiteral)]
[not(ancestor::Expression/ConditionalOrExpression//EqualityExpression[@Image='==']//NullLiteral)]

          
          ]]></value>
         </property>
      </properties>
      <example><![CDATA[

class Foo {
 boolean bar(String x) {
  return x.equals("2"); // should be "2".equals(x)
 }
}


  ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UnnecessaryLocalBeforeReturn" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UnnecessaryLocalBeforeReturn" message="Consider simply returning the value vs storing it in local variable ''{0}''" name="UnnecessaryLocalBeforeReturn" since="3.3" typeResolution="true">
      <description>
Avoid unnecessarily creating local variables
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
  public class Foo {
    public int foo() {
      int x = doSomething();
      return x;  // instead, just 'return doSomething();'
    }
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.NonThreadSafeSingleton" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#NonThreadSafeSingleton" message="Singleton is not thread safe" name="NonThreadSafeSingleton" since="3.4" typeResolution="true">
      <description>
Non-thread safe singletons can result in bad state changes. Eliminate
static singletons if possible by instantiating the object directly. Static
singletons are usually not needed as only a single instance exists anyway.
Other possible fixes are to synchronize the entire method or to use an
initialize-on-demand holder class (do not use the double-check idiom).

See Effective Java, item 48.
        </description>
      <priority>1</priority>
      <properties>
         <property name="checkNonStaticFields" value="false"/>
         <property name="checkNonStaticMethods" value="true"/>
      </properties>
      <example><![CDATA[
private static Foo foo = null;

//multiple simultaneous callers may see partially initialized objects
public static Foo getFoo() {
    if (foo==null)
        foo = new Foo();
    return foo;
}
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UncommentedEmptyMethod" message="Document empty method" name="UncommentedEmptyMethod" since="3.4" typeResolution="true">
      <description>
Uncommented Empty Method finds instances where a method does not contain
statements, but there is no comment. By explicitly commenting empty methods
it is easier to distinguish between intentional (commented) and unintentional
empty methods.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//MethodDeclaration/Block[count(BlockStatement) = 0 and @containsComment = 'false']
 
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public void doSomething() {
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UncommentedEmptyConstructor" message="Document empty constructor" name="UncommentedEmptyConstructor" since="3.4" typeResolution="true">
      <description>
Uncommented Empty Constructor finds instances where a constructor does not
contain statements, but there is no comment. By explicitly commenting empty
constructors it is easier to distinguish between intentional (commented)
and unintentional empty constructors.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and ($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false']
 
             ]]></value>
         </property>
         <property name="ignoreExplicitConstructorInvocation" value="false"/>
      </properties>
      <example><![CDATA[
  
public Foo() {
  super();
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AvoidConstantsInterface" message="An Interface should be used only to model a behaviour; consider converting this to a class." name="AvoidConstantsInterface" since="3.5" typeResolution="true">
      <description>An interface should be used only to model a behaviour of a
    class: using an interface as a container of constants is a poor usage pattern.</description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[//ClassOrInterfaceDeclaration[@Interface="true"]
    [
     count(.//MethodDeclaration)=0
     and
     count(.//FieldDeclaration)>0
    ]]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
    public interface ConstantsInterface {
     public static final int CONSTANT1=0;
     public static final String CONSTANT2="1";
    }
    
      ]]></example>
      <example><![CDATA[public interface ConstantsInterface {
     public static final int CONSTANT1=0;
     public static final String CONSTANT2="1";
    }]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UnsynchronizedStaticDateFormatter" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UnsynchronizedStaticDateFormatter" message="Static DateFormatter objects should be accessed in a synchronized manner" name="UnsynchronizedStaticDateFormatter" since="3.6" typeResolution="true">
      <description>
SimpleDateFormat is not synchronized. Sun recomends separate format instances
for each thread. If multiple threads must access a static formatter, the
formatter must be synchronized either on method or block level.
      </description>
      <priority>1</priority>
      <example><![CDATA[
    
public class Foo {
    private static final SimpleDateFormat sdf = new SimpleDateFormat();
    void bar() {
        sdf.format(); // bad
    }
    synchronized void foo() {
        sdf.format(); // good
    }
}
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.PreserveStackTrace" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#PreserveStackTrace" message="New exception is thrown in catch block, original stack trace may be lost" name="PreserveStackTrace" since="3.7" typeResolution="true">
      <description>
Throwing a new exception from a catch block without passing the original exception into the
new exception will cause the true stack trace to be lost, and can make it difficult to
debug effectively.
      </description>
      <priority>1</priority>
      <example><![CDATA[
    
public class Foo {
    void good() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e);
        }
    }
    void bad() {
        try{
            Integer.parseInt("a");
        } catch(Exception e){
            throw new Exception(e.getMessage());
        }
    }
}
    
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.UseCollectionIsEmpty" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#UseCollectionIsEmpty" message="Substitute calls to size() == 0 (or size() != 0) with calls to isEmpty()" name="UseCollectionIsEmpty" since="3.9" typeResolution="true">
      <description>The isEmpty() method on java.util.Collection is provided to see if a collection has any elements.
Comparing the value of size() to 0 merely duplicates existing behavior.</description>
      <priority>1</priority>
      <example><![CDATA[
    
	public class Foo {
		void good() {
        	List foo = getList();
			if (foo.isEmpty()) {
				// blah
			}
    	}

	    void bad() {
    	    List foo = getList();
				if (foo.size() == 0) {
					// blah
				}
	    	}
	}
    
      ]]></example>
      <example><![CDATA[public class Foo {
		void good() {
        	List foo = getList();
			if (foo.isEmpty()) {
				// blah
			}
    	}

	    void bad() {
    	    List foo = getList();
				if (foo.size() == 0) {
					// blah
				}
	    	}
	}]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ClassWithOnlyPrivateConstructorsShouldBeFinal" message="A class which only has private constructors should be final" name="ClassWithOnlyPrivateConstructorsShouldBeFinal" since="4.1" typeResolution="true">
      <description>
A class with only private constructors should be final, unless the private
constructor is called by a inner class.
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
TypeDeclaration[count(../TypeDeclaration) = 1]/ClassOrInterfaceDeclaration
[@Final = 'false']
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[@Private = 'true']) >= 1 ]
[count(./ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/ConstructorDeclaration[(@Public = 'true') or (@Protected = 'true') or (@PackagePrivate = 'true')]) = 0]
[not(.//ClassOrInterfaceDeclaration)]
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
public class Foo {  //Should be final
    private Foo() { }
}
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#EmptyMethodInAbstractClassShouldBeAbstract" message="An empty method in an abstract class should be abstract instead" name="EmptyMethodInAbstractClassShouldBeAbstract" since="4.1" typeResolution="true">
      <description>
An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation
rather than code the appropriate one.
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
                    //ClassOrInterfaceDeclaration[@Abstract = 'true']
                        /ClassOrInterfaceBody
                        /ClassOrInterfaceBodyDeclaration
                        /MethodDeclaration[@Abstract = 'false' and @Native = 'false']
                        [
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral) = 'true' )
                            or
                            ( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '0']) = 'true' )
                    		or
							( boolean(./Block[count(./BlockStatement) =  1]/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[string-length(@Image) = 2]) = 'true' )
							or
							(
								(
									(boolean(./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal[@Image = '']) = 'true' )
								)
								and
								( count (./Block/*) = 1 )
							)
                            or
                            ( count (./Block/*) = 0 )
                        ]
                
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        	
				public abstract class ShouldBeAbstract
				{
				    public Object couldBeAbstract()
				    {
					// Should be abstract method ?
					return null;
				   	}

				    public void couldBeAbstract()
				    {
				    }
				}
	     	
    	]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.SingularField" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SingularField" message="Perhaps ''{0}'' could be replaced by a local variable." name="SingularField" since="3.1" typeResolution="true">
      <description>
      		
This field is used in only one method and the first usage is assigning a value
to the field. This probably means that the field can be changed to a local variable.
			
      </description>
      <priority>1</priority>
      <properties>
         <property name="DisallowNotAssignment" value="false"/>
         <property name="CheckInnerClasses" value="false"/>
      </properties>
      <example><![CDATA[
public class Foo {
    private int x;  //Why bother saving this?
    public void foo(int y) {
     x = y + 5;
     return x;
    }
}
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#ReturnEmptyArrayRatherThanNull" message="Return an empty array rather than 'null'." name="ReturnEmptyArrayRatherThanNull" since="4.2" typeResolution="true">
      <description>
            
            For any method that returns an array, it's a better behavior to return an empty array rather than a null reference.
            
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
                        //MethodDeclaration
                        [
                        (./ResultType/Type[@Array='true'])
                        and
                        (./Block/BlockStatement/Statement/ReturnStatement/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral)
                        ]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
            public class Example
            {
                // Not a good idea...
                public int []badBehavior()
                {
                    // ...
                    return null;
                }

                // Good behavior
                public String[] bonnePratique()
                {
                    //...
                    return new String[0];
                }
            }
            
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#AbstractClassWithoutAnyMethod" message="No abstract method which means that the  keyword is most likely used to prevent instantiation. use a private or protected constructor instead." name="AbstractClassWithoutAnyMethod" since="4.2" typeResolution="true">
      <description>
            
			If the abstract class does not provides any methods, it may be just a data container that is not to be instantiated. In this case, it's probably
			better to use a private or a protected constructor in order to prevent instantiation than make the class misleadingly abstract.
            
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//ClassOrInterfaceDeclaration[
	(@Abstract = 'true')
	and
	(count(//MethodDeclaration) + count(//ConstructorDeclaration) = 0)
]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
            
public class abstract Example {
	String field;
	int otherField;
}
            
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#TooFewBranchesForASwitchStatement" message="A switch with less than 3 branches is inefficient, use a if statement instead." name="TooFewBranchesForASwitchStatement" since="4.2" typeResolution="true">
      <description>
		    
			     Swith are designed complex branches, and allow branches to share treatement. Using a switch for only a few 
			     branches is ill advised, as switches are not as easy to understand as if. In this case, it's most likely
			     is a good idea to use a if statement instead, at least to increase code readability.
			     
	    </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
				    
					     //SwitchStatement[
					     (count(.//SwitchLabel) < $minimumNumberCaseForASwitch)
								      ]
								      
					     ]]></value>
         </property>
         <property name="minimumNumberCaseForASwitch" value="3"/>
      </properties>
      <example><![CDATA[
				     
// With a minimumNumberCaseForASwitch of 3	    
public class Foo {
	public void bar() {
		switch (condition) {
			case ONE:
				instruction;
				break;
			default:
				break; // not enough for a 'switch' stmt, a simple 'if' stmt would have been more appropriate
		}
	}
}
					      
			     ]]></example>
   </rule>
</ruleset>
